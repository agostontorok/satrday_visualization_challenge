---
title: "satRday challenge"
author: "Agoston Torok & Fanni Kling"
date: '2016 augusztus 18 '
output: html_document
---

```{r setup, tidy = TRUE,  include=FALSE}
#install.packages(pkgs="gdata")
options(java.parameters = "-Xmx4000m")
if (!"xlsx" %in% installed.packages()) install.packages("xlsx")
library("xlsx")


if (file.exists("BUD flights 2007-2012.csv")){
  df <- read.csv("BUD flights 2007-2012.csv", colClasses = c(rep("character", 7),
                                                              "Date",
                                                              "numeric",
                                                              rep("character", 3),
                                                              rep("numeric", 4)))
} else {
  recodeR <- function(data, oldvalue, newvalue) {
      # create the return vector
      oldvalue <- c(as.character(oldvalue))
      newvalue <- c(as.character(newvalue))
      data <- c(as.character(data))
      newvec <- data
      # put recoded values into the correct position in the return vector
      for (i in unique(oldvalue)) newvec[data == i] <- newvalue[oldvalue == i]
      newvec
  }
  
  
  # read the Hungarian version because the English was messed up
  df <- read.xlsx2("BUD flights 2007-2012.xlsx", sheetIndex = 2,
                   colClasses = c(rep("character", 7),
                                    "Date",
                                    "numeric",
                                    rep("character", 3),
                                    rep("numeric", 4)), 
                   encoding="UTF-8")
  colNamesDict <- read.xlsx("BUD flights 2007-2012.xlsx", sheetIndex = 3, encoding="UTF-8")
  destinationDict <- read.xlsx("BUD flights 2007-2012.xlsx", sheetIndex = 4, encoding="UTF-8")
  countryDict <- read.xlsx("BUD flights 2007-2012.xlsx", sheetIndex = 7, encoding="UTF-8")
  colNamesDict$English <- gsub(" ",".",colNamesDict$English)
  colnames(df) <- recodeR(colnames(df),colNamesDict$Hungarian, colNamesDict$English)
  df$COMMERCIAL.FLAG <- recodeR(df$COMMERCIAL.FLAG,colNamesDict$Hungarian, colNamesDict$English)
  df$FLIGH.DIRECTION <- recodeR(df$FLIGH.DIRECTION,colNamesDict$Hungarian, colNamesDict$English)
  df$FLIGHT.TYPE <- recodeR(df$FLIGHT.TYPE,colNamesDict$Hungarian, colNamesDict$English)
  df$DESTINATION <- recodeR(df$DESTINATION, destinationDict$Hujngarian, destinationDict$English)
  df$COUNTRY <- recodeR(df$COUNTRY, countryDict$Hungarian, countryDict$English)
  
  write.csv(df, "BUD flights 2007-2012.csv", row.names=FALSE)
}
```


```{r}
# https://susanejohnston.wordpress.com/2012/10/01/find-and-replace-in-r-part-2-how-to-recode-many-values-simultaneously/


```


## Map Creation

First let's read the longitude and lattitude coordinates of the the different countries [citation](https://www.r-bloggers.com/r-beginners-plotting-locations-on-to-a-world-map/). 

```{r readLocations}
library(stringi)
if (!"ggmap" %in% installed.packages()) install.packages("ggmap")
library(ggmap)

locationsCountryFileName <- "locations_country_lon_lat.csv"

if (file.exists(locationsCountryFileName)){
  locationCountryCoordinates <- read.csv(locationsCountryFileName, header = TRUE)
} else {
  destinationCountries <- unique(as.character(df$COUNTRY))
  locationCountryCoordinates <- geocode(destinationCountries)
  locationCountryCoordinates$COUNTRY <- destinationCountries
  write.csv(locationCountryCoordinates, locationsCountryFileName)
}

locationsCityFileName <- "locations_cities_lon_lat.csv"

if (file.exists(locationsCityFileName)){
  locationCityCoordinates <- read.csv(locationsCityFileName)
} else {
  destinationCities <- unique(as.character(df$DESTINATION))
  locationCityCoordinates <- geocode(destinationCities)
  locationCityCoordinates$DESTINATION <- destinationCities
  write.csv(locationCityCoordinates, locationsCityFileName)
}

library(plyr)
  
locationCountryCoordinates$X <- NULL
locationCityCoordinates$X <- NULL

locationCityCoordinates <- rename(locationCityCoordinates, c("lon"="lonCi", "lat"="latCi"))
df <- merge(df, locationCityCoordinates)
locationCountryCoordinates <- rename(locationCountryCoordinates, c("lon"="lonCo", "lat"="latCo"))
df <- merge(df, locationCountryCoordinates)
```

Then display a world map using the [Mollweide projection](https://en.wikipedia.org/wiki/Mollweide_projection). This projection is used because it emphasizes the accuracy of relative sizes of land and sea parts. The method used here is based on the example and polygon of [Bob Rudis](http://stackoverflow.com/a/27901570/5360901). For the animation we used the [gganimate](https://www.ggplot2-exts.org/gganimate.html) package by David Robinson. 

Because we were working on Windows, setting up ffmepeg and imagemagick required a little effort. With imagemagick 


```{r staticWorldMap}
if (!"sp" %in% installed.packages()) install.packages("sp")
library("sp")
if (!"maps" %in% installed.packages()) install.packages("maps")
library("maps")
if (!"rgdal" %in% installed.packages()) install.packages("rgdal")
library("rgdal")
if (!"rgeos" %in% installed.packages()) install.packages("rgeos")
library("rgeos")
if (!"gganimate" %in% installed.packages()) devtools::install_github("dgrtwo/gganimate")
library(gganimate)


world <- readOGR("ne_50m_admin_0_countries.geojson", "OGRGeoJSON")
outline <- bbox(world)
outline <- data.frame(xmin=outline["x","min"],
                      xmax=outline["x","max"],
                      ymin=outline["y","min"],
                      ymax=outline["y","max"])

world <- fortify(world)

points <- data.frame(lon=c(-98.35, 134.21), lat=c(39.5, -25.36))

gg <- ggplot()
# first let's create the sea
gg <- gg + geom_rect(data=outline, 
                     aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax), 
                     color=1, fill="lightblue", size=0.3)
# then let the land emerge
gg <- gg + geom_map(data=world, map=world,
                    aes(x=long, y=lat, map_id=id), 
                    fill="darkseagreen", color="gray10", size=0.3)
# then let people populate the Earth
gg <- gg + geom_point(aes(x=lon, y=lat, size=CARGO.WEIGHT, frame=DATE),
                      data=df, col="orange", alpha=0.4)
gg <- gg + coord_map("mollweide")

# make the plot pretty
gg <- gg + theme_bw()
gg <- gg + labs(x=NULL, y=NULL)
gg <- gg + theme(panel.grid=element_blank(),
                 legend.position="none", panel.border=element_blank(),
                 axis.ticks=element_blank(),
                 axis.text=element_blank())
#gg_animate(gg, interval = 0.2, saver = "mp4", filename = "cargo_weights.mp4") #, filename="cargo_weight.gif")

```


```{r}
library(ggmap)
library(mapproj)

df2 <- aggregate(CARGO.WEIGHT ~ DESTINATION + FLIGH.DIRECTION, df, sum)
df2$colorCARGO.WEIGHT <- df2$CARGO.WEIGHT # this going to be the colour of the markers
df2$sizeCARGO.WEIGHT <- df2$CARGO.WEIGHT  # this is going to be the size of the markers

df2[df2$FLIGH.DIRECTION == "Incoming","colorCARGO.WEIGHT"] <- df2[df2$FLIGH.DIRECTION == "Incoming","colorCARGO.WEIGHT"] *-1

df2 <- aggregate(. ~ DESTINATION, df2[ ,c(1,4:5)], sum)
df2 <- df2[df2$sizeCARGO.WEIGHT > 0, ] 

df2 <- merge(df2, locationCityCoordinates)

map <- get_map(location = 'Serbia', zoom = 4, maptype = "terrain")

gg <- ggmap(map)
gg <- gg + geom_point(data = df2, 
                 aes(x = lonCi, y = latCi, 
                     size = sizeCARGO.WEIGHT, color = colorCARGO.WEIGHT), 
                 alpha = 0.9)
gg <- gg + geom_text(data = df2, 
                 aes(label = DESTINATION, x = lonCi, y = latCi, 
                     size = sizeCARGO.WEIGHT, color = colorCARGO.WEIGHT), 
                 alpha = 0.9, hjust = 1.1, vjust = 1) 
gg <- gg + theme_bw() + scale_colour_gradient(low = "blue", high = "red",
                                              guide = guide_colourbar(title = "Difference"))
gg <- gg + labs(x=NULL, y=NULL, size='Cargo weight' )
gg <- gg + theme(panel.grid=element_blank(),
                 panel.border=element_blank(),
                 axis.ticks=element_blank(),
                 axis.text=element_blank())
print(gg)
```



```{r}
library(ggmap)
library(mapproj)


df2 <- aggregate(NBR.OF.PASSENGERS ~ DESTINATION + FLIGH.DIRECTION, df, sum)
df2$colorNBR.OF.PASSENGERS <- df2$NBR.OF.PASSENGERS # this going to be the colour of the markers
df2$sizeNBR.OF.PASSENGERS <- df2$NBR.OF.PASSENGERS  # this is going to be the size of the markers

df2[df2$FLIGH.DIRECTION == "Incoming","colorNBR.OF.PASSENGERS"] <- df2[df2$FLIGH.DIRECTION == "Incoming","colorNBR.OF.PASSENGERS"] *-1

df2 <- aggregate(. ~ DESTINATION, df2[ ,c(1,4:5)], sum)
df2 <- df2[df2$sizeNBR.OF.PASSENGERS > 0, ] 

df2 <- merge(df2, locationCityCoordinates)

map <- get_map(location = 'Serbia', zoom = 4, maptype = "roadmap")

gg <- ggmap(map)
gg <- gg + geom_point(data = df2, 
                 aes(x = lonCi, y = latCi, size = sizeNBR.OF.PASSENGERS, 
                     fill = colorNBR.OF.PASSENGERS) , colour="black", pch=21) 
gg <- gg + theme_bw() + scale_fill_gradient2(low = "blue", mid = "white", high = "red", guide = "colorbar")
gg <- gg + labs(x=NULL, y=NULL) 
gg <- gg + theme(panel.grid=element_blank(),
                 #legend.position="none", 
                 panel.border=element_blank(),
                 axis.ticks=element_blank(),
                 axis.text=element_blank())
print(gg)
```

This looks very interesting, however there are a lot of destinations. Giving text annotations for all of them would make the graph crowded, so we choosed an interactive visualization instead. [Plotly](https://plot.ly/) recently made available its mapping toolkit along with the offline version of their D3.js based plotting solution. We used jet colormap to display the difference between incoming and outgoing passenger numbers to a given airport. The size of the markers is proportionate to the sum passengers in that direction. The plot is zoomable & hoverable, this way even the smaller airports can be seen well. 

```{r}
#devtools::install_github("ropensci/plotly")
library(plotly)

df2$hover <- with(df2, paste("Destination: ", DESTINATION))
df2$scaled_sizeNBR.OF.PASSENGERS <- df2$sizeNBR.OF.PASSENGERS / 30000
df2$Difference <- df2$colorNBR.OF.PASSENGERS

# marker styling
m <- list(
  colorbar = list(title = "Millions USD"),
  size = ~scaled_sizeNBR.OF.PASSENGERS, 
  opacity = 0.8, 
  symbol = 'circle'
)

# color of markers
jet <- c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")

# axis styling
ax <- list(
  title = "",
  zeroline = FALSE,
  showline = FALSE,
  showticklabels = FALSE,
  showgrid = FALSE
)

# geo styling
g <- list(
  scope = 'world',
  projection = list(type = 'albers europe'),
  showland = TRUE,
  lonaxis = list(range = c(-20,50)),
  lataxis = list(range = c(20,70)),
  landcolor = toRGB("gray65"),
  subunitcolor = toRGB("white"),
  countrycolor = toRGB("white"),
  countrywidth = 1,
  subunitwidth = 1
)

plot_ly(df2, lat = ~latCi, lon = ~lonCi, text = ~hover, color = ~Difference,
        type = 'scattergeo', locationmode = 'country names', mode = 'markers',
        colors = jet, marker = m) %>% 
  layout(title = 'Incoming/outgoing passengers of Liszt Ferenc Airport', geo = g, xaxis = ax, yaxis = ax)
```


http://stackoverflow.com/questions/37329433/how-to-build-simple-google-chart-in-shiny

https://trinkerrstuff.wordpress.com/2013/05/11/animations-understood-5/


